import type { AxiosRequestConfig } from 'axios';

export declare enum Border {
    black = 0,
    borderless = 1,
    gold = 2,
    silver = 3,
    white = 4
}

export declare interface BulkDataDefinition {
    compressed_size: number;
    content_encoding: string;
    content_type: string;
    description: string;
    download_uri: string;
    id: string;
    name: string;
    object: 'bulk_data';
    type: BulkDataType;
    updated_at: string;
    uri: string;
}

export declare type BulkDataType = keyof typeof BulkDataTypes;

export declare enum BulkDataTypes {
    oracle_cards = 0,
    unique_artwork = 1,
    default_cards = 2,
    all_cards = 3,
    rulings = 4
}

export declare interface Card {
    all_parts?: RelatedCard[];
    arena_id?: number;
    artist?: string;
    artist_ids?: string[];
    booster: boolean;
    border_color: keyof typeof Border;
    card_back_id: string;
    card_faces?: CardFace[];
    cmc: number;
    collector_number: string;
    color_identity: Color[];
    color_indicator?: Color[];
    colors?: Color[];
    digital: boolean;
    edhrec_rank?: number;
    flavor_text?: string;
    foil: boolean;
    frame: '1993' | '1997' | '2003' | '2015' | 'Future';
    frame_effects?: (keyof typeof FrameEffect)[];
    full_art: boolean;
    games: (keyof typeof Game)[];
    hand_modifier?: string;
    highres_image: boolean;
    id: string;
    illustration_id?: string;
    image_uris?: ImageUris;
    lang: string;
    layout: keyof typeof Layout;
    legalities: Legalities;
    life_modifier?: string;
    loyalty?: string;
    mana_cost?: string;
    mtgo_foil_id?: number;
    mtgo_id?: number;
    multiverse_ids?: number[];
    name: string;
    nonfoil: boolean;
    object: 'card';
    oracle_id: string;
    oracle_text?: string;
    oversized: boolean;
    power?: string;
    preview?: Preview;
    prices: Prices;
    printed_name?: string;
    printed_text?: string;
    printed_type_line?: string;
    prints_search_uri: string;
    promo: boolean;
    promo_types?: (keyof typeof PromoType)[];
    purchase_uris: PurchaseUris;
    rarity: keyof typeof Rarity;
    related_uris: RelatedUris;
    released_at: string;
    reprint: boolean;
    reserved: boolean;
    rulings_uri: string;
    scryfall_set_uri: string;
    scryfall_uri: string;
    set: string;
    set_name: string;
    set_search_uri: string;
    set_type: Set_2['set_type'];
    set_uri: string;
    story_spotlight: boolean;
    tcgplayer_id?: number;
    textless: boolean;
    toughness?: string;
    type_line: string;
    uri: string;
    variation: boolean;
    variation_of?: string;
    watermark?: string;
}

export declare interface CardFace {
    artist?: string;
    color_indicator?: Color[];
    colors: Color[];
    flavor_text?: string;
    illustration_id?: string;
    image_uris?: ImageUris;
    loyalty?: string;
    mana_cost: string;
    name: string;
    object: 'card_face';
    oracle_text?: string;
    power?: string;
    printed_name?: string;
    printed_text?: string;
    printed_type_line?: string;
    toughness?: string;
    type_line: string;
    watermark?: string;
}

export declare interface CardIdentifier {
    collector_number?: string;
    id?: string;
    illustration_id?: string;
    mtgo_id?: number;
    multiverse_id?: number;
    name?: string;
    oracle_id?: string;
    set?: string;
}

export declare class CardIdentifierBuilder {
    static byId(id: string): CardIdentifier;
    static byIllustrationId(id: string): CardIdentifier;
    static byMtgoId(id: number): CardIdentifier;
    static byMultiverseId(id: number): CardIdentifier;
    static byName(name: string, set?: string): CardIdentifier;
    static byOracleId(id: string): CardIdentifier;
    static bySet(set: string, collectorNumber: number | string): CardIdentifier;
}

export declare const Cards: Cards_2;

declare class Cards_2 extends MagicQuery {
    autoCompleteName(name: string): Promise<string[]>;
    byArenaId(id: number): Promise<Card | undefined>;
    byId(id: string): Promise<Card | undefined>;
    byMtgoId(id: number): Promise<Card | undefined>;
    byMultiverseId(id: number): Promise<Card | undefined>;
    byName(name: string, fuzzy?: boolean): Promise<Card | undefined>;
    byName(name: string, set?: string, fuzzy?: boolean): Promise<Card | undefined>;
    bySet(setCode: string, collectorNumber: number, lang?: string): Promise<Card | undefined>;
    byTcgPlayerId(id: number): Promise<Card | undefined>;
    collection(...identifiers: CardIdentifier[]): Promise<Card[]>;
    random(): Promise<Card | undefined>;
    search(query: string, options?: SearchOptions | number): MagicPageResult<Card, Cards_2>;
}

export declare interface CardSymbol {
    appears_in_mana_costs: boolean;
    colors: Color[];
    converted_mana_cost?: number;
    english: string;
    funny: boolean;
    gatherer_alternates?: string[];
    loose_variant?: string;
    represents_mana: boolean;
    symbol: string;
    transposable: boolean;
}

export declare const Catalog: Catalog_2;

declare class Catalog_2 extends MagicQuery {
    artifactTypes(): Promise<string[]>;
    artistNames(): Promise<string[]>;
    cardNames(): Promise<string[]>;
    creatureTypes(): Promise<string[]>;
    enchantmentTypes(): Promise<string[]>;
    landTypes(): Promise<string[]>;
    loyalties(): Promise<string[]>;
    planeswalkerTypes(): Promise<string[]>;
    powers(): Promise<string[]>;
    spellTypes(): Promise<string[]>;
    toughnesses(): Promise<string[]>;
    watermarks(): Promise<string[]>;
    wordBank(): Promise<string[]>;
}

export declare type Color = keyof typeof Colors;

declare enum Colors {
    W = 0,
    B = 1,
    R = 2,
    U = 3,
    G = 4
}

export declare enum Format {
    standard = 0,
    future = 1,
    historic = 2,
    pioneer = 3,
    modern = 4,
    legacy = 5,
    pauper = 6,
    vintage = 7,
    penny = 8,
    commander = 9,
    brawl = 10,
    duel = 11,
    oldschool = 12
}

export declare enum FrameEffect {
    legendary = 0,
    miracle = 1,
    nyxtouched = 2,
    draft = 3,
    devoid = 4,
    tombstone = 5,
    colorshifted = 6,
    inverted = 7,
    sunmoondfc = 8,
    compasslanddfc = 9,
    originpwdfc = 10,
    mooneldrazidfc = 11,
    moonreversemoondfc = 12,
    showcase = 13,
    extendedart = 14
}

export declare enum Game {
    paper = 0,
    arena = 1,
    mtgo = 2
}

export declare interface HomepageLink {
    badge?: string;
    created_at: string;
    id: number;
    priority: number;
    text: string;
    updated_at: string;
    uri: string;
}

export declare interface ImageUris {
    art_crop: string;
    border_crop: string;
    large: string;
    normal: string;
    png: string;
    small: string;
}

export declare enum Layout {
    normal = 0,
    split = 1,
    flip = 2,
    transform = 3,
    modal_dfc = 4,
    meld = 5,
    leveler = 6,
    'class' = 7,
    saga = 8,
    adventure = 9,
    planar = 10,
    scheme = 11,
    vanguard = 12,
    token = 13,
    double_faced_token = 14,
    emblem = 15,
    augment = 16,
    host = 17,
    art_series = 18,
    reversible_card = 19
}

export declare type Legalities = {
    [key in keyof typeof Format]: keyof typeof Legality;
};

export declare enum Legality {
    legal = 0,
    not_legal = 1,
    restricted = 2,
    banned = 3
}

declare class MagicPageResult<T, Q extends MagicQuery, P = unknown> {
    private readonly q;
    private readonly apiPath;
    private readonly query;
    private readonly post?;
    private _count;
    private _hasMore;
    constructor(q: Q, apiPath: string, query: PageQuery, post?: P | undefined);
    get count(): number;
    get hasMore(): boolean;
    all(): Promise<T[]>;
    get(limit: number): Promise<T[]>;
    next(): Promise<T[]>;
    page(page: number): Promise<T[]>;
    private setNextPage;
}

declare abstract class MagicQuery {
    static retry: RetryStrategy;
    private static readonly endpoint;
    private static lastQuery;
    private static readonly rateLimit;
    private static canRetry;
    private static debounce;
    private static sleep;
    private static tryQuery;
    query<T = unknown, Y = unknown>(apiPath: TOrArrayOfT<number | string | undefined>, query?: Query, post?: Y, requestOptions?: AxiosRequestConfig): Promise<T | undefined>;
}

export declare class MagicQueryError extends Error {
    readonly data?: string | SearchError | undefined;
    constructor(data?: string | SearchError | undefined);
}

export declare interface ManaCost {
    cmc: number;
    colorless: boolean;
    colors: Color[];
    cost: string;
    monocolored: boolean;
    multicolored: boolean;
}

export declare type PageQuery = {
    [key: string]: QueryValue;
    page: number;
};

export declare interface Preview {
    previewed_at?: string;
    source?: string;
    source_uri?: string;
}

export declare interface Prices {
    eur?: string;
    tix?: string;
    usd?: string;
    usd_foil?: string;
}

export declare enum PromoType {
    tourney = 0,
    prerelease = 1,
    datestamped = 2,
    planeswalkerdeck = 3,
    buyabox = 4,
    judgegift = 5,
    event = 6,
    convention = 7,
    starterdeck = 8,
    instore = 9,
    setpromo = 10,
    fnm = 11,
    openhouse = 12,
    league = 13,
    draftweekend = 14,
    gameday = 15,
    release = 16,
    intropack = 17,
    giftbox = 18,
    duels = 19,
    wizardsplaynetwork = 20,
    premiereshop = 21,
    playerrewards = 22,
    gateway = 23,
    arenaleague = 24
}

export declare interface PurchaseUris {
    [key: string]: string | undefined;
    cardhoarder?: string;
    cardmarket?: string;
    tcgplayer?: string;
}

export declare type Query = {
    [key: string]: QueryValue;
};

export declare type QueryValue = boolean | number | string | undefined;

export declare enum Rarity {
    common = 0,
    uncommon = 1,
    rare = 2,
    mythic = 3
}

export declare interface RelatedCard {
    component: keyof typeof RelatedCardComponent;
    id: string;
    name: string;
    object: 'related_card';
    type_line: string;
    uri: string;
}

export declare enum RelatedCardComponent {
    token = 0,
    meld_part = 1,
    meld_result = 2,
    combo_piece = 3
}

export declare interface RelatedUris {
    [key: string]: string | undefined;
    edhrec?: string;
    gatherer?: string;
    mtgtop8?: string;
    tcgplayer_decks?: string;
}

export declare type ResultCatalog = ResultData<string>;

export declare interface ResultData<T, NOT_FOUND = never> {
    data: T[];
    not_found?: NOT_FOUND[];
}

export declare interface ResultList<T, NOT_FOUND = never> extends ResultData<T, NOT_FOUND> {
    has_more: boolean;
    next_page: string;
    total_cards: string;
    warnings: string[];
}

export declare interface RetryStrategy {
    attempts: number;
    /**
     * Whether even `not_found` and `bad_request` errors should be retried.
     * @deprecated Don't use this, this is for unit tests
     */
    forced?: boolean;
    timeout?: number;
    canRetry?(error?: SearchError): boolean;
}

export declare interface Ruling {
    comment: string;
    published_at: string;
    source: string;
}

export declare const Rulings: Rulings_2;

declare class Rulings_2 extends MagicQuery {
    byArenaId(id: number): Promise<Ruling[]>;
    byId(id: string): Promise<Ruling[]>;
    byMtgoId(id: number): Promise<Ruling[]>;
    byMultiverseId(id: number): Promise<Ruling[]>;
    bySet(setCode: string, collectorNumber: number | string): Promise<Ruling[]>;
}

export declare interface SearchError {
    code: string;
    details: string;
    object: 'error';
    status: number;
    warnings?: string[];
}

export declare interface SearchOptions {
    dir?: keyof typeof SortDirection;
    include_extras?: boolean;
    include_multilingual?: boolean;
    include_variations?: boolean;
    order?: keyof typeof Sort;
    /**
     * The page to start on. Defaults to `1`, for first page. A page is 175 cards.
     */
    page?: number;
    unique?: keyof typeof UniqueStrategy;
}

declare interface Set_2 {
    block?: string;
    block_code?: string;
    card_count: number;
    code: string;
    digital: boolean;
    foil_only: boolean;
    icon_svg_uri: string;
    id: string;
    mtgo_code?: string;
    name: string;
    parent_set_code?: string;
    released_at?: string;
    scryfall_uri: string;
    search_uri: string;
    set_type: keyof typeof SetType;
    tcgplayer_id?: number;
    uri: string;
}
export { Set_2 as Set }

export declare const Sets: Sets_2;

declare class Sets_2 extends MagicQuery {
    all(): Promise<Set_2[]>;
    byCode(code: string): Promise<Set_2 | undefined>;
    byId(id: string): Promise<Set_2 | undefined>;
    byTcgPlayerId(id: number): Promise<Set_2 | undefined>;
}

export declare enum SetType {
    core = 0,
    expansion = 1,
    masters = 2,
    masterpiece = 3,
    from_the_vault = 4,
    spellbook = 5,
    premium_deck = 6,
    duel_deck = 7,
    draft_innovation = 8,
    treasure_chest = 9,
    commander = 10,
    planechase = 11,
    archenemy = 12,
    vanguard = 13,
    funny = 14,
    starter = 15,
    box = 16,
    promo = 17,
    token = 18,
    memorabilia = 19,
    alchemy = 20,
    arsenal = 21
}

export declare enum Sort {
    name = 0,
    set = 1,
    released = 2,
    rarity = 3,
    color = 4,
    usd = 5,
    tix = 6,
    eur = 7,
    cmc = 8,
    power = 9,
    toughness = 10,
    edhrec = 11,
    artist = 12
}

export declare enum SortDirection {
    auto = 0,
    asc = 1,
    desc = 2
}

export declare const Symbology: Symbology_2;

declare class Symbology_2 extends MagicQuery {
    all(): Promise<CardSymbol[]>;
    parseMana(shorthand: string): Promise<ManaCost | undefined>;
}

export declare type TOrArrayOfT<T> = T | T[];

export declare enum UniqueStrategy {
    cards = 0,
    art = 1,
    prints = 2
}

export { }
