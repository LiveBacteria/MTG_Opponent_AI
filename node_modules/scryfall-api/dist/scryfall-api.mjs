import g from "axios";
class J {
  static byId(a) {
    return { id: a };
  }
  static byIllustrationId(a) {
    return { illustration_id: a };
  }
  static byMtgoId(a) {
    return { mtgo_id: a };
  }
  static byMultiverseId(a) {
    return { multiverse_id: a };
  }
  static byName(a, e) {
    return e ? { name: a, set: e } : { name: a };
  }
  static byOracleId(a) {
    return { oracle_id: a };
  }
  static bySet(a, e) {
    return { collector_number: `${e}`, set: a };
  }
}
class w {
  constructor(a, e, r, n) {
    this.q = a, this.apiPath = e, this.query = r, this.post = n, this._hasMore = !0, this._count = 0;
  }
  _count;
  _hasMore;
  get count() {
    return this._count;
  }
  get hasMore() {
    return this._hasMore;
  }
  async all() {
    const a = [];
    for (; this._hasMore; ) {
      const e = await this.next();
      a.push(...e);
    }
    return a;
  }
  async get(a) {
    const e = [];
    for (; this._hasMore; ) {
      const r = await this.next();
      if (e.push(...r), e.length === a)
        return e;
      if (e.length > a)
        return e.slice(0, a);
    }
    return e;
  }
  async next() {
    const a = await this.q.query(this.apiPath, this.query, this.post);
    return this._hasMore = a?.has_more ?? !1, this._count = Number.parseInt(`${a?.total_cards ?? 0}`, 10), this._hasMore && this.setNextPage(), a?.data ?? [];
  }
  async page(a) {
    return this.query.page = a, this.next();
  }
  setNextPage() {
    this.query.page = this.query.page + 1;
  }
}
class d extends Error {
  constructor(a) {
    super(typeof a == "string" ? a : a?.details), this.data = a, Object.setPrototypeOf(this, d.prototype);
  }
}
class t {
  static retry = { attempts: 1 };
  // the path to the api
  static endpoint = "https://api.scryfall.com";
  // time when the last api call was made
  static lastQuery = 100;
  // the api requests 50-100 ms between calls, we go on the generous side and never wait less than 100 ms between calls
  static rateLimit = 100;
  static canRetry(a) {
    return typeof a == "string" || a?.code === "not_found" || a?.code === "bad_request" ? !1 : !t.retry.canRetry || t.retry.canRetry(a);
  }
  static async debounce() {
    const a = Date.now(), e = a - t.lastQuery;
    if (e >= t.rateLimit)
      t.lastQuery = a;
    else {
      const r = t.rateLimit - e;
      t.lastQuery += r, await t.sleep(r);
    }
  }
  static async sleep(a = 0) {
    return new Promise((e) => {
      setTimeout(e, a);
    });
  }
  static async tryQuery(a, e, r, n) {
    await t.debounce();
    const c = {
      data: r,
      method: r ? "POST" : "GET",
      params: e,
      url: `${t.endpoint}/${a}`,
      headers: { "Accept-Encoding": "gzip,deflate,compress" },
      ...n
    };
    try {
      return await g.request(c);
    } catch (i) {
      if (i.isAxiosError) {
        const l = i;
        throw new d(l.response?.data ?? l.message);
      } else
        throw i;
    }
  }
  async query(a, e, r, n) {
    let c = "";
    typeof a == "number" || typeof a == "string" ? c = a : a && (c = a.join("/"));
    let i, l;
    for (i = 0; i < t.retry.attempts; i++) {
      let h;
      try {
        l = await t.tryQuery(`${c}`, e, r, n);
      } catch (u) {
        if (u instanceof d)
          h = u.data;
        else
          throw u;
      }
      if (l || !t.canRetry(h))
        break;
      await t.sleep(t.retry.timeout);
    }
    return l?.data;
  }
}
class o extends t {
  async autoCompleteName(a) {
    return (await this.query("cards/autocomplete", {
      q: a
    }))?.data ?? [];
  }
  async byArenaId(a) {
    return this.query(["cards/arena", a]);
  }
  async byId(a) {
    return this.query(["cards", a]);
  }
  async byMtgoId(a) {
    return this.query(["cards/mtgo", a]);
  }
  async byMultiverseId(a) {
    return this.query(["cards/multiverse", a]);
  }
  async byName(a, e, r = !1) {
    let n = r, c = e;
    return typeof e == "boolean" && (n = e, c = void 0), this.query("cards/named", {
      [n ? "fuzzy" : "exact"]: a,
      set: c
    });
  }
  async bySet(a, e, r) {
    const n = ["cards", a, e];
    return r && n.push(r), this.query(n);
  }
  async byTcgPlayerId(a) {
    return this.query(["cards/tcgplayer", a]);
  }
  async collection(...a) {
    const e = [];
    for (let r = 0; r < a.length; r += 75) {
      const n = { identifiers: a.slice(r, r + 75) }, c = await this.query(
        "cards/collection",
        void 0,
        n
      );
      e.push(...c?.data ?? []);
    }
    return e;
  }
  async random() {
    return this.query("cards/random");
  }
  search(a, e) {
    return new w(this, "cards/search", {
      q: a,
      ...typeof e == "number" ? { page: e } : { page: 1, ...e }
    });
  }
}
const K = new o();
class b extends t {
  async artifactTypes() {
    return (await this.query("catalog/artifact-types"))?.data ?? [];
  }
  async artistNames() {
    return (await this.query("catalog/artist-names"))?.data ?? [];
  }
  async cardNames() {
    return (await this.query("catalog/card-names"))?.data ?? [];
  }
  async creatureTypes() {
    return (await this.query("catalog/creature-types"))?.data ?? [];
  }
  async enchantmentTypes() {
    return (await this.query("catalog/enchantment-types"))?.data ?? [];
  }
  async landTypes() {
    return (await this.query("catalog/land-types"))?.data ?? [];
  }
  async loyalties() {
    return (await this.query("catalog/loyalties"))?.data ?? [];
  }
  async planeswalkerTypes() {
    return (await this.query("catalog/planeswalker-types"))?.data ?? [];
  }
  async powers() {
    return (await this.query("catalog/powers"))?.data ?? [];
  }
  async spellTypes() {
    return (await this.query("catalog/spell-types"))?.data ?? [];
  }
  async toughnesses() {
    return (await this.query("catalog/toughnesses"))?.data ?? [];
  }
  async watermarks() {
    return (await this.query("catalog/watermarks"))?.data ?? [];
  }
  async wordBank() {
    return (await this.query("catalog/word-bank"))?.data ?? [];
  }
}
const V = new b();
class v extends t {
  async byArenaId(a) {
    return (await this.query(["cards/arena", a, "rulings"]))?.data ?? [];
  }
  async byId(a) {
    return (await this.query(["cards", a, "rulings"]))?.data ?? [];
  }
  async byMtgoId(a) {
    return (await this.query(["cards/mtgo", a, "rulings"]))?.data ?? [];
  }
  async byMultiverseId(a) {
    return (await this.query(["cards/multiverse", a, "rulings"]))?.data ?? [];
  }
  async bySet(a, e) {
    return (await this.query([
      "cards",
      a,
      `${e}`,
      "rulings"
    ]))?.data ?? [];
  }
}
const W = new v();
class q extends t {
  async all() {
    return (await this.query("sets"))?.data ?? [];
  }
  async byCode(a) {
    return await this.query(["sets", a]);
  }
  async byId(a) {
    return this.query(["sets", a]);
  }
  async byTcgPlayerId(a) {
    return this.query(["sets/tcgplayer", a]);
  }
}
const X = new q();
class _ extends t {
  async all() {
    return (await this.query("symbology"))?.data ?? [];
  }
  async parseMana(a) {
    return await this.query("symbology/parse-mana", {
      cost: a
    });
  }
}
const Y = new _();
var x = /* @__PURE__ */ ((s) => (s[s.black = 0] = "black", s[s.borderless = 1] = "borderless", s[s.gold = 2] = "gold", s[s.silver = 3] = "silver", s[s.white = 4] = "white", s))(x || {}), k = /* @__PURE__ */ ((s) => (s[s.oracle_cards = 0] = "oracle_cards", s[s.unique_artwork = 1] = "unique_artwork", s[s.default_cards = 2] = "default_cards", s[s.all_cards = 3] = "all_cards", s[s.rulings = 4] = "rulings", s))(k || {}), m = /* @__PURE__ */ ((s) => (s[s.standard = 0] = "standard", s[s.future = 1] = "future", s[s.historic = 2] = "historic", s[s.pioneer = 3] = "pioneer", s[s.modern = 4] = "modern", s[s.legacy = 5] = "legacy", s[s.pauper = 6] = "pauper", s[s.vintage = 7] = "vintage", s[s.penny = 8] = "penny", s[s.commander = 9] = "commander", s[s.brawl = 10] = "brawl", s[s.duel = 11] = "duel", s[s.oldschool = 12] = "oldschool", s))(m || {}), y = /* @__PURE__ */ ((s) => (s[s.legendary = 0] = "legendary", s[s.miracle = 1] = "miracle", s[s.nyxtouched = 2] = "nyxtouched", s[s.draft = 3] = "draft", s[s.devoid = 4] = "devoid", s[s.tombstone = 5] = "tombstone", s[s.colorshifted = 6] = "colorshifted", s[s.inverted = 7] = "inverted", s[s.sunmoondfc = 8] = "sunmoondfc", s[s.compasslanddfc = 9] = "compasslanddfc", s[s.originpwdfc = 10] = "originpwdfc", s[s.mooneldrazidfc = 11] = "mooneldrazidfc", s[s.moonreversemoondfc = 12] = "moonreversemoondfc", s[s.showcase = 13] = "showcase", s[s.extendedart = 14] = "extendedart", s))(y || {}), f = /* @__PURE__ */ ((s) => (s[s.paper = 0] = "paper", s[s.arena = 1] = "arena", s[s.mtgo = 2] = "mtgo", s))(f || {}), I = /* @__PURE__ */ ((s) => (s[s.normal = 0] = "normal", s[s.split = 1] = "split", s[s.flip = 2] = "flip", s[s.transform = 3] = "transform", s[s.modal_dfc = 4] = "modal_dfc", s[s.meld = 5] = "meld", s[s.leveler = 6] = "leveler", s[s.class = 7] = "class", s[s.saga = 8] = "saga", s[s.adventure = 9] = "adventure", s[s.planar = 10] = "planar", s[s.scheme = 11] = "scheme", s[s.vanguard = 12] = "vanguard", s[s.token = 13] = "token", s[s.double_faced_token = 14] = "double_faced_token", s[s.emblem = 15] = "emblem", s[s.augment = 16] = "augment", s[s.host = 17] = "host", s[s.art_series = 18] = "art_series", s[s.reversible_card = 19] = "reversible_card", s))(I || {}), p = /* @__PURE__ */ ((s) => (s[s.legal = 0] = "legal", s[s.not_legal = 1] = "not_legal", s[s.restricted = 2] = "restricted", s[s.banned = 3] = "banned", s))(p || {}), $ = /* @__PURE__ */ ((s) => (s[s.tourney = 0] = "tourney", s[s.prerelease = 1] = "prerelease", s[s.datestamped = 2] = "datestamped", s[s.planeswalkerdeck = 3] = "planeswalkerdeck", s[s.buyabox = 4] = "buyabox", s[s.judgegift = 5] = "judgegift", s[s.event = 6] = "event", s[s.convention = 7] = "convention", s[s.starterdeck = 8] = "starterdeck", s[s.instore = 9] = "instore", s[s.setpromo = 10] = "setpromo", s[s.fnm = 11] = "fnm", s[s.openhouse = 12] = "openhouse", s[s.league = 13] = "league", s[s.draftweekend = 14] = "draftweekend", s[s.gameday = 15] = "gameday", s[s.release = 16] = "release", s[s.intropack = 17] = "intropack", s[s.giftbox = 18] = "giftbox", s[s.duels = 19] = "duels", s[s.wizardsplaynetwork = 20] = "wizardsplaynetwork", s[s.premiereshop = 21] = "premiereshop", s[s.playerrewards = 22] = "playerrewards", s[s.gateway = 23] = "gateway", s[s.arenaleague = 24] = "arenaleague", s))($ || {}), N = /* @__PURE__ */ ((s) => (s[s.common = 0] = "common", s[s.uncommon = 1] = "uncommon", s[s.rare = 2] = "rare", s[s.mythic = 3] = "mythic", s))(N || {}), z = /* @__PURE__ */ ((s) => (s[s.token = 0] = "token", s[s.meld_part = 1] = "meld_part", s[s.meld_result = 2] = "meld_result", s[s.combo_piece = 3] = "combo_piece", s))(z || {}), A = /* @__PURE__ */ ((s) => (s[s.core = 0] = "core", s[s.expansion = 1] = "expansion", s[s.masters = 2] = "masters", s[s.masterpiece = 3] = "masterpiece", s[s.from_the_vault = 4] = "from_the_vault", s[s.spellbook = 5] = "spellbook", s[s.premium_deck = 6] = "premium_deck", s[s.duel_deck = 7] = "duel_deck", s[s.draft_innovation = 8] = "draft_innovation", s[s.treasure_chest = 9] = "treasure_chest", s[s.commander = 10] = "commander", s[s.planechase = 11] = "planechase", s[s.archenemy = 12] = "archenemy", s[s.vanguard = 13] = "vanguard", s[s.funny = 14] = "funny", s[s.starter = 15] = "starter", s[s.box = 16] = "box", s[s.promo = 17] = "promo", s[s.token = 18] = "token", s[s.memorabilia = 19] = "memorabilia", s[s.alchemy = 20] = "alchemy", s[s.arsenal = 21] = "arsenal", s))(A || {}), j = /* @__PURE__ */ ((s) => (s[s.name = 0] = "name", s[s.set = 1] = "set", s[s.released = 2] = "released", s[s.rarity = 3] = "rarity", s[s.color = 4] = "color", s[s.usd = 5] = "usd", s[s.tix = 6] = "tix", s[s.eur = 7] = "eur", s[s.cmc = 8] = "cmc", s[s.power = 9] = "power", s[s.toughness = 10] = "toughness", s[s.edhrec = 11] = "edhrec", s[s.artist = 12] = "artist", s))(j || {}), O = /* @__PURE__ */ ((s) => (s[s.auto = 0] = "auto", s[s.asc = 1] = "asc", s[s.desc = 2] = "desc", s))(O || {}), M = /* @__PURE__ */ ((s) => (s[s.cards = 0] = "cards", s[s.art = 1] = "art", s[s.prints = 2] = "prints", s))(M || {});
export {
  x as Border,
  k as BulkDataTypes,
  J as CardIdentifierBuilder,
  K as Cards,
  V as Catalog,
  m as Format,
  y as FrameEffect,
  f as Game,
  I as Layout,
  p as Legality,
  d as MagicQueryError,
  $ as PromoType,
  N as Rarity,
  z as RelatedCardComponent,
  W as Rulings,
  A as SetType,
  X as Sets,
  j as Sort,
  O as SortDirection,
  Y as Symbology,
  M as UniqueStrategy
};
